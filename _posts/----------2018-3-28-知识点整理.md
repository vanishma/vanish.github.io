---
layout: post
title: java知识点整理
subtitle: java 知识点
date: 2018-3-28
author: vanish
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
  - java
  - 知识点
  - 沉淀
---

# java知识点整理

# 接口和抽象类

1、接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则

2、抽象类和接口的区别在于使用动机。使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。

抽象类里面可以有非抽象方法但接口只能有抽象方法，声明方法的存在而不去实现它的类叫做抽象类，它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能再该类中实现该类的情况。

抽象类不能直接new对象，他只能被基层，而单一继承，也就是说他把公共的东西抽象出来，之类可以调用父类的方法也可以拓展自己的功能，就想子承父业一样。接口可以被多次基层，这是和抽象类的最大区别。也就是说接口是一个公共用品谁都可以拿来用的。不像抽象类，不是他的子类不能调用

当描述一组方法的时候使用接口  当描述一个虚拟的物体的时候使用抽象类

所有的抽象类必须要有子类

抽象类的子类必须覆写抽象方法

抽象类的对象可以通过对象多态性利用子类为实例化

# hashMap和hashTable的区别

hashMap几乎等价于hashTable，除了hashmap是非synchronized的，并可以接受null，而hashTable则不行。

hashmap是非synchronized，而hashtable是synchronized，这意味着hashtable是线程安全的，多个线程可以共享一个hashtable；而如果没有正确的同步的话，多个线程是不能共享的。

另一个区别是hashmap的迭代器(iterator) 是fail-fast迭代器，而hashtable的enumerator迭代器不是fail-fast的。所以当有其他线程改变了hashmap的结构(增加或者移除元素)。

由于hashtable是线程安全的也是synchronized，所以在单线程环境下它比hashmap要慢。如果hashmap不能保证随着时间的推移map中的元素次序是不变的。

# list和set的区别
list，set都是基层collection接口
list的特点：元素有放入顺序，元素可重复，set特点：元素无放入顺序，元素不可重复（元素虽然无放入顺序，但是元素在set中的位置有该元素的hashcode决定的，其位置是固定的。list接口有三个实现类：linkdlist、arraylist、vector。set接口有链各个实现类hashset（底部由hashmap实现），linkedhashet


# tomcat 服务器优化
1.内存优化：主要是对tomcat 启动参数进行优化，可以在tomcat启动脚本中修改它的最大内存数。

2.线程数优化：tomcat的并发连接参数，主要在tomcat配置文件中server.xml中配置，修改最小空闲连接线程数，用于提高系统处理性能。

3.优化缓存：打开压缩功能，修改参数，比如压缩输出内容大小默认为2kb，可以适当的修改。

# jvm的优化
设置参数，设置jvm的最大内存数
垃圾回收器的选择


# mysql索引种类
普通索引

唯一性索引

全文索引


# spring  ioc 和 aop
ioc 控制反转

ioc另外一种说法叫DI，既依赖注入。它并不是一种技术实现，而是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述他们特有的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管理自己有交互的类的引用和依赖，代码将会变的一场难以维护和极度的高耦合。而ioc的出现正是用来解决这个问题，我们通过ioc将这些相互依赖对象的创建、协助工作交个spring容器去处理，每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，获得依赖的对象的方式，进行了反转，变成了由spring容器控制对象如何获取外部资源。

aop：面向切面编程，往往被定义为促使软件系统实现关注点的分离的技术。系统是有许多不同的主键所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担额外的职责。例如日志、事物管理和安全这样的核心服务经常融入到自身具有核心业务讲逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。

aop的概念不好像ioc一样实例化举例，现在我们以一个系统中的具体实现来讲讲aop具体是个什么技术。

```
我们以系统中常用到的事物管控举例子。在系统操作数据库的过程中，不可避免地要考虑到事物相关的内容。
如果在每一个方法中都新建一个事物管理器，那么无疑是对代码严重的耦合和侵入。为了简化我们的开发过程
（实际上spring所做的一切实现都是为了简化开发过程），需要把事物相关的代码抽成出来做一个独立的模块。通过aop，
确认每一个操作数据库方法为一个连接点，这些连接点组成了一个切面。当程序运行到其中某一个切点时，
我们将事物管理模块顺势植入对象中，通过通知功能，完成整个事物管控的实现。这样一来，所有的操作数据库的方法中不需要再单独关心事物管理的内容，
只需要关注自身的业务代码的实现即可。所有的事物管控相关的内容都通过aop的方式进行了实现。
简化了代码的内容，将目标对象复杂的内容进行解耦，分离业务逻辑与横切关注点。
```
.通知：通知定义了切面是什么以及何时使用的概念。spring切面可以应用5中类型的通知：
  
  .前置通知（before）在目标方法被调用之前调用通知功能。

  .后置通知：（after）在目标方法完成之后调用通知，此时不会关心方法的输出是什么。

  .返回通知（after-returning）：在目标方法成功执行之后调用通知。

  .异常通知（after-throwing）：在目标方法抛出异常后调用通知。

  .环绕通知（around）：通知包裹了呗通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为

  连接点：是应用执行过程中能够插入切面的一个点。

  切点：切点定义了切面在何处要植入的一个或多个连接点

  切面：是通知和切点的结合。通知和切点共同定义了切面的全部内容

  引入：引入允许我们向现有类添加新方法或属性。

  织入：是把切面应用到目标对象，并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期中有多个点可以进行织入：

  编译期：在目标类编译时，切面被织入。这种方式需要特殊的编译器。aspectj的织入器就是以这种方式织入切面的。
  类加载期：切面在目标加载到jvm时被织入。种方式需要特殊的类加载器它可以在目标类被引入应用之前增强该目标类的字节码。

  运行期：切面在应用运行到某个时刻被织入。一般情况下，在织入切面时，aop容器会为目标对象动态地创建一个代理对象。springAop就是以这种方式织入切面的。
  